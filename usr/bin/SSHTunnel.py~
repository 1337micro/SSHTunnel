#!/usr/bin/python3

#import PySide classes
import sys

import os

from threading import Thread
import time
from time import sleep

from PySide.QtCore import *
from PySide.QtGui import *

from SSHDynamic import SSHDynamic

import subprocess
from subprocess import CalledProcessError
from subprocess import Popen
from subprocess import PIPE

import getpass # To get the username

import traceback


class _LaunchProgram():
    
    def __init__(self, command, sleep_time=0, end_process_after_sleep =False):
        
        self.command = command
        self.sleep_time = sleep_time
        self.end_process_after_sleep = end_process_after_sleep
    def run(self):
        subprocess.Popen(self.command)
        sleep(self.sleep_time)
        if (self.end_process_after_sleep):
            print("KILL")
            raise Exception("KILL")
            


class StartingWindow(QDialog):
    def __init__(self, parent= None):
        super(StartingWindow, self).__init__(parent)
        
        # Create a Label and show it
        self.label = QLabel("<b>SSHTunneling<b> \n<em>Use this program to setup a SOCKS proxy and protect your browsing or your applications from unauthorized viewing</em>")
        
        self.bExistingProxy = QPushButton("I have an ssh-capable server") #Button
        self.bSetUpProxy = QPushButton("Set up a server for me (Not implemented yet)")
        
        #### Set up the layout
        layout = QVBoxLayout()
        layout.addWidget(self.label)
        layout.addWidget(self.bExistingProxy)
        layout.addWidget(self.bSetUpProxy)
        self.setLayout(layout)
        ####
        #On click event
        self.serv_form = None
        self.bExistingProxy.clicked.connect(self.show_server_form)
        
        self.setWindowTitle("SSHTunneling")
        
    def show_server_form(self):
        #starting_window.hide()
        self.serv_form = ServerForm()            
        self.serv_form.show()
        
       

class ServerForm(QDialog):
    def __init__(self, parent=None):
        LOGNAME = getpass.getuser() # LINUX DEPENDANT, LOGNAME is the current user
        super(ServerForm, self).__init__(parent)
        self.setWindowTitle("SSHTunneling: Server setup and connect")
        #Attributes for setting up the SOCKS proxy
        self.user_prompt = QLabel("Username used to connect to server: ")
        self.user = QLineEdit("")
        self.server_prompt = QLabel("Server IP:")
        self.server = QLineEdit("")
        self.key_prompt = QLabel("ABSOLUTE path of the key file, blank if none required. (i.e.: if on Desktop, /home/" + LOGNAME + "/Desktop/keyfile , and NOT: Desktop/keyfile)")
        self.key = QLineEdit("")  
        self.sumbit = QPushButton("Sumbit and Connect")#Fowards the port 1080 locally and turns the ssh client into a SOCKS Proxy
        
        
        
        
        
        
        ##Retreive previously entered info
        os.chdir("/home/" + LOGNAME +"/.local/share")
        list_of_folders = os.listdir()
        for folder in list_of_folders:
            if "SSHTunnel" in folder:
                os.chdir("SSHTunnel/")
                serverform = open("server_form", "r")
                self.user = QLineEdit(serverform.readline()[0:-1])#Cut off the \n at then end
                self.server = QLineEdit(serverform.readline()[0:-1])
                self.key = QLineEdit(serverform.readline()[0:-1])
                serverform.close()
                break
        ##
        #
        self.key.setFixedWidth = 200
        ###
        layout = QVBoxLayout()
        layout.addWidget(self.user_prompt)
        layout.addWidget(self.user)
        layout.addWidget(self.server_prompt)
        layout.addWidget(self.server)
        layout.addWidget(self.key_prompt)
        layout.addWidget(self.key)
        layout.addWidget(self.sumbit)
        
        ###
        self.setLayout(layout)
        
        
        self.sumbit.clicked.connect(self.retrieve_info_and_connect)
        
        self.sshtun = None #Done to keep sshtun alive
        self.errmsg = None #Done to keep errmsg alive
    def retrieve_info_and_connect(self, local_port="1080"):
        try:           
            self.sshtun = SSHDynamic(self.user.text(), self.server.text(), self.key.text(), 'not_implemented')
            LOGNAME = getpass.getuser() # LINUX DEPENDANT, LOGNAME is the current user
            ### SAVE Settings for server form here
            os.chdir("/home/" + LOGNAME +"/.local/share")
            list_of_folders = os.listdir()
            for folder in list_of_folders:
                if "SSHTunnel" in folder:
                    os.chdir("SSHTunnel/")
                    serverform = open("server_form", "w")
                    serverform.write(self.sshtun.user+"\n")
                    serverform.write(self.sshtun.server+"\n")
                    serverform.write(self.sshtun.key+"\n")
                    serverform.close()
                    break
            else:
                subprocess.call(["mkdir", "SSHTunnel"])
                os.chdir("SSHTunnel/")
                serverform = open("server_form", "w")
                serverform.write(self.sshtun.user+"\n")
                serverform.write(self.sshtun.server+"\n")
                serverform.write(self.sshtun.key+"\n")
                serverform.close()
            ###
            
            if self.sshtun.key is not '' and self.sshtun.key is not 'Location of key file, blank if none required':
                try:
                    Popen(['fuser', '-k', '1080/tcp']) # Kills all tcp on 1080
                    pobj = Popen(['ssh','-Ctt','-D'+local_port,'-i',str(self.sshtun.key),str(self.sshtun.user) +'@' +str(self.sshtun.server)], stdout = subprocess.PIPE, stdin = subprocess.PIPE)
                    
                    
                    prestdin_time = time.time()
                    pobj.stdin.write(bytes('yes', 'UTF-8'))#For the initial setup certificate
                    pobj.stdin.close()
                    
                    sys.stdout.flush()
                    line = pobj.stdout.readline()
                    
                    while bytes('Welcome', 'UTF-8') not in line and line != bytes('', 'UTF-8'):
                        if(time.time() - prestdin_time > 5.0):
                            raise Exception("Connection taking too long")
                        sys.stdout.flush()
                        line = pobj.stdout.readline()
                    
                    print ("We seem to be connected")
                    starting_window.serv_form.hide() #Hide the server form window
                    starting_window.browser_or_other_page = BrowserOrOther()
                    starting_window.browser_or_other_page.show()  
                
                except Exception as e:
                    print(str(e) + str(e.args))
                    
                    self.errmsg = ErrorMessage("Connection error", str(e))
                    self.errmsg.show()
                    
                
                
                """ 
                ###Not supported in python3.2
                except subprocess.TimeoutExpired as e:
                    print(e)
                    print ("We seem to be connected")
                    starting_window.serv_form.hide() #Hide the server form window
                    starting_window.browser_or_other_page = BrowserOrOther()
                    starting_window.browser_or_other_page.show()
                """
            
            else:
                try:
                    Popen(['fuser', '-k', '1080/tcp']) # Kills all tcp on 1080
                    pobj = Popen(['ssh','-Ctt','-D' +local_port,str(self.sshtun.user)+'@'+str(self.sshtun.server)], stdout = subprocess.PIPE, stdin = subprocess.PIPE)
                    
                    
                    prestdin_time = time.time()
                    pobj.stdin.write(bytes('yes', 'UTF-8'))#For the initial setup certificate
                    pobj.stdin.close()
                    
                    sys.stdout.flush()
                    line = pobj.stdout.readline()
                    
                    while bytes('Welcome', 'UTF-8') not in line and line != bytes('', 'UTF-8'):
                        if(time.time() - prestdin_time > 5.0):
                            raise Exception("Connection taking too long")
                            sys.stdout.flush()
                        line = pobj.stdout.readline()
                        
                    print ("We seem to be connected")
                    starting_window.serv_form.hide() #Hide the server form window
                    starting_window.browser_or_other_page = BrowserOrOther()
                    starting_window.browser_or_other_page.show()
                    
                except Exception as e:
                    print(str(e))
                    self.errmsg = ErrorMessage("Connection error", str(e))
                    self.errmsg.show()
                """ python3.2 not supported
                except subprocess.TimeoutExpired as e:
                    print(e)
                    print ("We seem to be connected")
                    starting_window.serv_form.hide() #Hide the server form window
                    starting_window.browser_or_other_page = BrowserOrOther()
                    starting_window.browser_or_other_page.show()
                """
                
            
           
           
            
        except CalledProcessError as e:
            print(e)
            self.errmsg = ErrorMessage(str(e))
            self.errmsg.show()        
        
class BrowserOrOther(QDialog):
    def __init__(self, parent=None):
        super(BrowserOrOther, self).__init__(parent)
        self.setWindowTitle("SSHTunneling: Protect Internet browsing or some other application")
        #Attributes for setting up the SOCKS proxy
        
        self.sshtun = starting_window.serv_form.sshtun
        
        self.info_browse = QLabel("""
                           <b>SOCKS proxy:</b> routed locally (<em>ip: 127.0.0.1</em>) on the port: <em>1080</em> <br/>
                            Enter the above information in your browser's PROXY settings or click one of the buttons below<br/>
                            <br/>
                            <b><em>WARNING: </em>This might close any firefox/chrome windows you have opened!</b><br/>""")
        
        self.firefox = QPushButton("Launch special Firefox instance")
        self.chrome = QPushButton("Launch special Chrome instance")
        
        self.info_other = QLabel("Traffic other applications by writing their alias (e.g. irssi) or the path to the program below (followed by any arguments needed):") 
        self.program = QLineEdit("Program to launch")
        self.launch = QPushButton("Launch!")
        
        
        
        ###
        layout1 = QVBoxLayout()
        layout1.addWidget(self.info_browse)
        
        layout2 = QHBoxLayout()
        layout1.addLayout(layout2)
        layout2.addWidget(self.firefox)
        layout2.addWidget(self.chrome)
        
        layout1.addWidget(self.info_other)
        layout1.addWidget(self.program)
        layout1.addWidget(self.launch) 
        ###
        self.setLayout(layout1)
        
        self.firefox.clicked.connect(self.modifiy_firefox_proxy)
        self.chrome.clicked.connect(self.launch_chrome_instance) # we don't have to modify 
        self.launch.clicked.connect(self.launch_program)
    def launch_program(self):
        args = self.program.text().split(' ')
        args.insert(0,"tsocks")
        subprocess.Popen(args)
        
    def launch_chrome_instance(self):
        """Kill all chrome instances and launch a new instance with
        --proxy-server=socks5://127.0.0.1:1080
        
        Chrome instances seem to need to be killed otherwise the new instance
        will not tunnel through SSH at all Although, once the new instance has
        been started, more instances can be created (like you normally would) to
        browse the web without tunneling """
        
        subprocess.call(["killall", "chrome"]) #all firefox instance must be killed
        Popen(["google-chrome","--proxy-server=socks5://127.0.0.1:1080"])
        
    def modifiy_firefox_proxy(self, host = "127.0.0.1", port=1080):
        """Modifies the proxy settings under a new profile if necessary (for first-time use)
        
        also launches the special firefox instance
        """
        
        #If
        self.LOGNAME = getpass.getuser() # LINUX DEPENDANT, LOGNAME is the current user
        
        #Success: created profile 'random' at '/home/bluezone/.mozilla/firefox/jn6osaqs.random/prefs.js'
        os.chdir('/home/'+ str(self.LOGNAME) +'/.mozilla/firefox/')
        list_of_items = os.listdir(os.getcwd())
        for folder in list_of_items:
            if 'SSHTunnel' in folder:
                os.chdir(folder)
                list_of_items = os.listdir(os.getcwd())
                for file_name in list_of_items:
                    if 'prefs.js' in file_name:
                        prefs = open('prefs.js')
                        prefs_text = prefs.read()
                        if "network.proxy.socks" not in prefs_text:
                            #We need to create the profile again
                            print("Creating profile SSHTunnel")
                            os.chdir('/home/'+ str(self.LOGNAME) +'/.mozilla/firefox/')
                            self.create_profile_F()
                        else:
                            self.launch_firefox_instance()
                        break
        else:
            os.chdir('/home/'+ str(self.LOGNAME) +'/.mozilla/firefox/')
            self.create_profile_F()
        
        
        #subprocess.call(["firefox","-P","SSHTunnel"])
    def create_profile_F(self):
        """Function to create the SSHTunnel Firefox profile, all firefox instances must be closed (or they can be left open,
        but the function will killall firefox)
        
        user_pref("network.proxy.no_proxies_on", "");
        user_pref("network.proxy.socks", "127.0.0.1");
        user_pref("network.proxy.socks_port", 1080);
        user_pref("network.proxy.type", 1);
        """
       
        os.chdir('/home/'+ str(self.LOGNAME) +'/.mozilla/firefox/')
        subprocess.call(["killall", "firefox"]) #all firefox instance must be killed
        subprocess.check_call(["firefox","-CreateProfile","SSHTunnel"]) #Create a new Profile named SSHTunnel, WE SHOULD USE check_call to see if it's succesful (if not, we need to htop SIGTERM firefox)                
        list_of_items = os.listdir(os.getcwd())
        
        for folder in list_of_items:
            if 'SSHTunnel' in folder:
                os.chdir(folder)
                break
        else:
            raise Exception("Create new profile for firefox failed")
        
        prefs = open("prefs.js", "r") #Open for reading
        prefs_text = prefs.read()
        prefs.close()
        
        prefs = open("prefs.js", "a")#Open for appending
        if "network.proxy.socks" not in prefs_text: # Need more checks, but might work fine
            print("Writing network settings... 214")
            prefs.write('user_pref("network.proxy.no_proxies_on", "");')
            prefs.write('user_pref("network.proxy.socks", "127.0.0.1");')
            prefs.write('user_pref("network.proxy.socks_port", 1080);')
            prefs.write('user_pref("network.proxy.type", 1);')        
            
        else:
            print("network settings already written 221")
        
        prefs.close()
        self.launch_firefox_instance()
    #/home/bluezone/.mozilla/firefox/jn6osaqs.random/prefs.js'launch_firefox_instance
    def launch_firefox_instance(self, port= "1080"):
        """Launches an isolated firefox instance under the profile SSHTunnel and routes the traffic through the SOCKS proxy
        """
        os.chdir('/home/'+ str(self.LOGNAME) +'/.mozilla/firefox/')
        list_of_items = os.listdir(os.getcwd())
        for folder in list_of_items:
            if 'SSHTunnel' in folder:
                os.chdir(folder)
                break
        
        prefs = open("prefs.js", "r") #Open for reading
        prefs_text = prefs.read()
        prefs.close()
        
        prefs = open("prefs.js", "a")#Open for appending
        if "network.proxy.socks" not in prefs_text: # Need more checks, but might work fine
            print("Writing network settings... 267")
            prefs.write('user_pref("network.proxy.no_proxies_on", "");\n')
            prefs.write('user_pref("network.proxy.socks", "127.0.0.1");\n')
            prefs.write('user_pref("network.proxy.socks_port", ' +port +');\n')
            prefs.write('user_pref("network.proxy.type", 1);\n')        
        else:
            print("network settings already written 275")
        
        subprocess.Popen(["firefox", "-P", "SSHTunnel"])

class ErrorMessage(QDialog):
    def __init__(self, title='Error', message='Something went wrong, please modify settings and try again'):
        super(ErrorMessage, self).__init__()
        self.title = title
        self.setWindowTitle(self.title)
        self.message = message
        
        self.errmessage = QLabel(self.message)
        self.ok = QPushButton("Ok")#Fowards the port 1080 locally and turns the ssh client into a SOCKS Proxy
         
        ###
        layout = QVBoxLayout()
        layout.addWidget(self.errmessage)
        layout.addWidget(self.ok)
        
        ###
        self.setLayout(layout)
        self.ok.clicked.connect(self.close_window)
        
        
    def close_window(self):
        self.hide()
        
    
app = QApplication(sys.argv)
starting_window = StartingWindow()
starting_window.show()

# Enter Qt application main loop
app.exec_()

sys.exit()

#python3.4 Dropbox/Failed\ projects/shhtunneling/PySideTut.py

